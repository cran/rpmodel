<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Example P-model run</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>The rpmodel package implements the P-model as described in Stocker et al. (2019) <em>Geosci. Mod. Dev.</em> The main function available through the package is <code>rpmodel()</code>, which returns a list of quantities (see <code>?rpmodel</code>) for a given set of inputs. An additional set of important functions that are used within <code>rpmodel()</code> are also available through this package. Usage examples are given below.</p>

<p><strong>Important note:</strong></p>

<p>The P-model predicts how photosynthesis acclimates to a changing environment, coordinating stomatal conductance, Vcmax and Jmax. This yields a model that has the form of a light use efficiency model, where gross primary production scales linearly with absorbed light, as described in <a href="https://doi.org/10.5194/gmd-13-1545-2020">Stocker et al. 2020</a>. It is important to note that this implies that the P-model is valid only for simulating responses to the environment that evolve over the time scale at which the photosynthetic machinery (e.g., Rubisco) can be assumed to acclimate. Sensible choices are on the order of a couple of weeks to a month. In other words, the arguments (climatic forcing), provided to <code>rpmodel()</code> should represent typical daytime mean values, averaged across a couple of weeks. The output is then representative also for average values across the same time scale.</p>

<h2>Example P-model run</h2>

<p>Let&#39;s run the P-model, without \(J_{\text{max}}\) limitation (argument <code>method_jmaxlim = &quot;none&quot;</code>), for one point. The set of inputs, being temperature (<code>tc</code>), photosynthetic photon flux density (<code>ppfd</code>), vapour pressure deficit (<code>vpd</code>), ambient CO\(_2\) (<code>co2</code>), elevation (<code>elv</code>), and fraction of absorbed photosynthetically active radiation (<code>fapar</code>). The quantum yield efficiency parameter is provided as an argument (<code>kphio</code>) and corresponds to \(\widehat{\varphi_0}\) in Stocker et al. (2019) if the temperature-dependence of this parameter is ignored (argument <code>do_ftemp_kphio = FALSE</code>, corresponding to simulation setup &#39;ORG&#39; in Stocker et al. (2019)), or to \(\widehat{c_L}\) if the temperature-dependence of the quantum yield efficiency is included (argument <code>do_ftemp_kphio = TRUE</code>, used in simulation setups &#39;BRC&#39; and &#39;FULL&#39; in Stocker et al. (2019)). By default the optional argument <code>do_soilmstress</code> is set to <code>FALSE</code>, meaning that the empirical soil moisture stress function is not included. The unit cost ratio (\(\beta\) in Stocker et al. (2019)) is given by argument <code>beta</code>.</p>

<p>To run the <code>rpmodel()</code> function we can do:</p>

<pre><code class="r">library(rpmodel)
out_pmodel &lt;- rpmodel( 
  tc             = 20,           # temperature, deg C
  vpd            = 1000,         # Pa,
  co2            = 400,          # ppm,
  fapar          = 1,            # fraction  ,
  ppfd           = 30,           # mol/m2/d,
  elv            = 0,            # m.a.s.l.,
  kphio          = 0.049977,     # quantum yield efficiency as calibrated for setup ORG by Stocker et al. 2020 GMD,
  beta           = 146,          # unit cost ratio a/b,
  c4             = FALSE,
  method_optci   = &quot;prentice14&quot;,
  method_jmaxlim = &quot;wang17&quot;,
  do_ftemp_kphio = FALSE,        # corresponding to setup ORG
  do_soilmstress = FALSE,        # corresponding to setup ORG
  verbose        = TRUE
  )
</code></pre>

<pre><code>## Warning in rpmodel(tc = 20, vpd = 1000, co2 = 400, fapar = 1, ppfd = 30, :
## Atmospheric pressure (patm) not provided. Calculating it as a function of
## elevation (elv), assuming standard atmosphere (101325 Pa at sea level).
</code></pre>

<pre><code class="r">print(out_pmodel)
</code></pre>

<pre><code>## $gpp
## [1] 7.119192
## 
## $ca
## [1] 40.53
## 
## $gammastar
## [1] 3.339251
## 
## $kmm
## [1] 46.09928
## 
## $ns_star
## [1] 1.125361
## 
## $chi
## [1] 0.694352
## 
## $xi
## [1] 63.3145
## 
## $mj
## [1] 0.7123038
## 
## $mc
## [1] 0.3340838
## 
## $ci
## [1] 28.14209
## 
## $iwue
## [1] 7.742446
## 
## $gs
## [1] 0.04784805
## 
## $vcmax
## [1] 1.774218
## 
## $vcmax25
## [1] 2.78494
## 
## $jmax
## [1] 4.001452
## 
## $jmax25
## [1] 5.464979
## 
## $rd
## [1] 0.02818463
</code></pre>

<p>Above, we specified the model paramters (arguments <code>beta</code> and <code>kphio</code>). This overrides the defaults, where <code>rpmodel()</code> uses the parameters as calibrated by Stocker et al. (2019), depending on the choices for arguments <code>do_ftemp_kphio</code> and <code>do_soilmstress</code>:</p>

<pre><code class="r">kphio = ifelse(do_ftemp_kphio, ifelse(do_soilmstress, 0.087182, 0.081785), 0.049977)
beta = 146.0
apar_soilm = 0.0
bpar_soilm = 0.73300
</code></pre>

<p>The function returns a list of variables (see also man page by <code>?rpmodel</code>), including \(V_{\mathrm{cmax}}\), \(g_s\), and all the parameters of the photosynthesis model (\(K\), \(\Gamma^{\ast}\)), which are all internally consistent, as can be verified for&hellip; \[
c_i = c_a - A / g_s = \chi c_a
\]</p>

<pre><code class="r">c_molmass &lt;- 12.0107  # molecular mass of carbon
kphio &lt;- 0.05         # quantum yield efficiency, value as used in the function call to rpmodel()
ppfd &lt;- 30            # mol/m2/d, value as used in the function call to rpmodel()
fapar &lt;- 1            # fraction, value as used in the function call to rpmodel()
print( out_pmodel$ci )
</code></pre>

<pre><code>## [1] 28.14209
</code></pre>

<pre><code class="r">print( out_pmodel$ca - (out_pmodel$gpp / c_molmass) / out_pmodel$gs )
</code></pre>

<pre><code>## [1] 28.14209
</code></pre>

<pre><code class="r">print( out_pmodel$ca * out_pmodel$chi )
</code></pre>

<pre><code>## [1] 28.14209
</code></pre>

<p>Yes.</p>

<p>And for&hellip; 
\[
A = V_{\text{cmax}} \frac{c_i-\Gamma^{\ast}}{c_i + K} = \phi_0 I_{\text{abs}} \frac{c_i-\Gamma^{\ast}}{c_i + 2 \Gamma^{\ast}} = g_s (c_a - c_i)
\]</p>

<pre><code class="r">print( out_pmodel$gpp / c_molmass )
</code></pre>

<pre><code>## [1] 0.5927375
</code></pre>

<pre><code class="r">print( out_pmodel$vcmax * (out_pmodel$ci - out_pmodel$gammastar) / (out_pmodel$ci + out_pmodel$kmm ))
</code></pre>

<pre><code>## [1] 0.5927375
</code></pre>

<pre><code class="r">print( out_pmodel$gs * (out_pmodel$ca - out_pmodel$ci) )
</code></pre>

<pre><code>## [1] 0.5927375
</code></pre>

<pre><code class="r">print( kphio * ppfd * fapar * (out_pmodel$ci - out_pmodel$gammastar) / (out_pmodel$ci + 2 * out_pmodel$gammastar ))
</code></pre>

<pre><code>## [1] 1.068456
</code></pre>

<p>Yes.</p>

<h3>Elevation and pressure</h3>

<p>Above, atmospheric pressure (<code>patm</code>) was not provided as an argument, but elevation (<code>elv</code>) was. Hence the warning was printed (only when <code>verbose = TRUE</code>), saying: <code>Atmospheric pressure (patm) not provided. Calculating it as a function of elevation (elv),</code> <code>Assuming standard atmosphere (101325 Pa at sea level).</code>. Alternatively, we can provide atmospheric pressure (<code>patm</code>) as input, which overrides the argument <code>elv</code>.</p>

<h3>P-model for time series</h3>

<p>The <code>rpmodel()</code> function can also be invoked for time series, where <code>tc</code>, <code>vpd</code>, <code>co2</code>, <code>fapar</code>, <code>patm</code>, and <code>ppfd</code> are vectors.</p>

<pre><code class="r">set.seed(1982)
out_ts_pmodel &lt;- rpmodel( 
  tc             = 20 + rnorm(5, mean = 0, sd = 5),
  vpd            = 1000 + rnorm(5, mean = 0, sd = 50),
  co2            = rep(400, 5),
  fapar          = rep(1, 5),
  ppfd           = 30 + rnorm(5, mean = 0, sd = 3),
  elv            = 0,         
  kphio          = 0.049977,
  beta           = 146,
  c4             = FALSE,
  method_optci   = &quot;prentice14&quot;,
  method_jmaxlim = &quot;none&quot;,
  do_ftemp_kphio = TRUE,
  do_soilmstress = FALSE,
  verbose        = FALSE
  )
print(out_ts_pmodel$gpp)
</code></pre>

<pre><code>## [1] 8.162522 7.967237 8.148933 7.468270 8.968635
</code></pre>

<p>Note that <code>gpp</code> (as well as all other returned variables) are now vectors of the same length as the vectors provided as inputs.</p>

<h3>P-model in the tidyverse</h3>

<p>We can create a data frame (in <a href="https://www.tidyverse.org/">tidyverse</a> this is a tibble) and apply the <code>rpmodel()</code> function to each row.</p>

<pre><code class="r">library(dplyr)
library(purrr)

set.seed(1982)

df &lt;- tibble(
  tc             = 20 + rnorm(5, mean = 0, sd = 5),
  vpd            = 1000 + rnorm(5, mean = 0, sd = 50),
  co2            = rep(400, 5),
  fapar          = rep(1, 5),
  ppfd           = 30 + rnorm(5, mean = 0, sd = 3)
  ) %&gt;%
  mutate( out_pmodel = purrr::pmap(., rpmodel, 
    elv            = 0,         
    kphio          = 0.049977,
    beta           = 146,
    c4             = FALSE,
    method_optci   = &quot;prentice14&quot;,
    method_jmaxlim = &quot;none&quot;,
    do_ftemp_kphio = FALSE
    ) )

print(df)
</code></pre>

<p>Note that the new column <code>out_pmodel</code> now contains the list returned as output of the <code>rpmodel()</code> function applied to each row separately. Additional (constant) arguments are just passed to <code>purrr::pmap</code> as arguments.</p>

<p>If you prefer the elements of these lists to be in separate columns of <code>df</code>, use tidyr to do:</p>

<pre><code class="r">library(tidyr)
df &lt;- df %&gt;% 
  mutate( out_pmodel = purrr::map(out_pmodel, ~as_tibble(.))) %&gt;% 
  unnest(out_pmodel)
print(df)
</code></pre>

<h2>Auxiliary functions</h2>

<p>A number of auxiliary functions, which are used within <code>rpmodel()</code>, are available (public) through the package.</p>

<h3>Instantaneous temperature scaling</h3>

<p>Different instantaneous temperature scaling functions are applied for \(V_\text{cmax}\) and dark respiration (\(R_d\)).</p>

<ul>
<li>  <code>ftemp_inst_vcmax()</code> calculates the instantaneous temperature response of \(V_\text{cmax}\). Let&#39;s run the P-model for <code>tc = 10</code> (degrees C). The ratio of \(V_\text{cmax}/V_\text{cmax25}\) should equal the instantaneous temperature scaling function for \(V_\text{cmax}\) at 10 degrees C (calculated by <code>ftemp_inst_vcmax(10)</code>):</li>
</ul>

<pre><code class="r">out_pmodel &lt;- rpmodel( 
  tc             = 10,           # temperature, deg C
  vpd            = 1000,         # Pa,
  co2            = 400,          # ppm,
  fapar          = 1,            # fraction  ,
  ppfd           = 30,           # mol/m2/d,
  elv            = 0,            # m.a.s.l.,
  kphio          = 0.049977,     # quantum yield efficiency as calibrated for setup ORG by Stocker et al. 2020 GMD,
  beta           = 146,          # unit cost ratio a/b,
  method_optci   = &quot;prentice14&quot;,
  method_jmaxlim = &quot;none&quot;,
  do_ftemp_kphio = FALSE,
  verbose        = TRUE
  )
</code></pre>

<pre><code>## Warning in rpmodel(tc = 10, vpd = 1000, co2 = 400, fapar = 1, ppfd = 30, :
## Atmospheric pressure (patm) not provided. Calculating it as a function of
## elevation (elv), assuming standard atmosphere (101325 Pa at sea level).
</code></pre>

<pre><code class="r">print(paste(&quot;Ratio Vcmax/Vcmax25      :&quot;, out_pmodel$vcmax/out_pmodel$vcmax25))
</code></pre>

<pre><code>## [1] &quot;Ratio Vcmax/Vcmax25      : 0.260975632963417&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;ftemp_inst_vcmax(10):&quot;, ftemp_inst_vcmax(10)))
</code></pre>

<pre><code>## [1] &quot;ftemp_inst_vcmax(10): 0.260975632963417&quot;
</code></pre>

<ul>
<li><p><code>ftemp_arrh()</code> Calculates the Arrhenius-type temperature response and is used inside <code>ftemp_inst_vcmax()</code>.</p></li>
<li><p><code>ftemp_inst_rd()</code> calculates the temperature response of dark respiration (\(R_d\)), which is slightly less steep than that for \(V_\text{cmax}\):</p></li>
</ul>

<pre><code class="r">print(paste(&quot;ftemp_inst_rd(10):&quot;, ftemp_inst_rd(10)))
</code></pre>

<pre><code>## [1] &quot;ftemp_inst_rd(10): 0.284933345928884&quot;
</code></pre>

<h3>Parameters in the FvCB model</h3>

<ul>
<li>  <code>gammastar()</code> calculates the CO\(_2\) compensation point (\(\Gamma^\ast\)) in the Farquhar-von Caemmerer-Berry model as a function of temperature (argument <code>tc</code>) and atmospheric pressure (argument <code>patm</code>). This is returned by the <code>rpmodel()</code> function and by the separate auxiliary function <code>gammastar()</code>. <code>gammastar()</code> requires atmospheric pressure (<code>patm</code>) to be given as an argument (in addition to temperature). Corresponding to the <code>rpmodel()</code> call above, let&#39;s calculate this using the auxiliary function <code>patm()</code> with 0 metres above sea level, and assuming standard atmospheric pressure (101325 Pa at 0 m a.s.l.):</li>
</ul>

<pre><code class="r">print(paste(&quot;From rpmodel call :&quot;, out_pmodel$gammastar))
</code></pre>

<pre><code>## [1] &quot;From rpmodel call : 1.93016150706341&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;gammastar(10):&quot;, gammastar(10, patm = patm(elv = 0))))
</code></pre>

<pre><code>## [1] &quot;gammastar(10): 1.93016150706341&quot;
</code></pre>

<ul>
<li>  <code>kmm()</code> calculates the Michaelis Menten coefficient for Rubisco-limited photosynthesis as a function of temperature (argument <code>tc</code>) and atmospheric pressure (argument <code>patm</code>). As above, <code>kmm()</code> requires atmospheric pressure to be given as an argument (in addition to temperature). Corresponding to the <code>rpmodel()</code> call above, let&#39;s calculate this using the auxiliary function <code>patm()</code> with 0 metres above sea level, and assuming standard atmospheric pressure (101325 Pa at 0 m a.s.l.):</li>
</ul>

<pre><code class="r">print(paste(&quot;From rpmodel call:&quot;, out_pmodel$kmm))
</code></pre>

<pre><code>## [1] &quot;From rpmodel call: 19.6242174524746&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;kmm(10)     :&quot;, kmm(10, patm = patm(elv = 0))))
</code></pre>

<pre><code>## [1] &quot;kmm(10)     : 19.6242174524746&quot;
</code></pre>

<h3>Temperature dependence of quantum yield efficiency</h3>

<p>The temperature dependence of quantum yield efficiency is modelled following Bernacchi et al. (2003), if the argument to the <code>rpmodel()</code> call <code>do_ftemp_kphio = TRUE</code>. This affects several quantities returned by the <code>rpmodel()</code> call (GPP, LUE, Vcmax), and can be calculated direction using <code>ftemp_kphio()</code>.</p>

<pre><code class="r">out_pmodel_ftemp_kphio_ON &lt;- rpmodel( 
  tc             = 20,           # temperature, deg C
  vpd            = 1000,         # Pa,
  co2            = 400,          # ppm,
  fapar          = 1,            # fraction  ,
  ppfd           = 30,           # mol/m2/d,
  elv            = 0,            # m.a.s.l.,
  do_ftemp_kphio = TRUE
  )
out_pmodel_ftemp_kphio_OFF &lt;- rpmodel( 
  tc             = 20,           # temperature, deg C
  vpd            = 1000,         # Pa,
  co2            = 400,          # ppm,
  fapar          = 1,            # fraction  ,
  ppfd           = 30,           # mol/m2/d,
  elv            = 0,            # m.a.s.l.,
  do_ftemp_kphio = FALSE
  )
print(paste(&quot;LUE ftemp_ON /LUE ftemp_OFF =&quot;, out_pmodel_ftemp_kphio_ON$lue / out_pmodel_ftemp_kphio_OFF$lue))
</code></pre>

<pre><code>## [1] &quot;LUE ftemp_ON /LUE ftemp_OFF = &quot;
</code></pre>

<pre><code class="r">print(paste(&quot;GPP ftemp_ON /GPP ftemp_OFF =&quot;, out_pmodel_ftemp_kphio_ON$gpp / out_pmodel_ftemp_kphio_OFF$gpp))
</code></pre>

<pre><code>## [1] &quot;GPP ftemp_ON /GPP ftemp_OFF = 1.07351301598735&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;Vcmax ftemp_ON /Vcmax ftemp_OFF =&quot;, out_pmodel_ftemp_kphio_ON$vcmax / out_pmodel_ftemp_kphio_OFF$vcmax))
</code></pre>

<pre><code>## [1] &quot;Vcmax ftemp_ON /Vcmax ftemp_OFF = 1.07351301598735&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;ftemp_kphio(20) =&quot;, ftemp_kphio(20)))
</code></pre>

<pre><code>## [1] &quot;ftemp_kphio(20) = 0.656&quot;
</code></pre>

<h3>Soil moisture stress</h3>

<p>The soil moisture stress function is available as a separate public function.</p>

<pre><code class="r">vec_soilm &lt;- seq(from = 1.0, to = 0.0, by = -0.05)
vec_soilmstress &lt;- soilmstress( vec_soilm, meanalpha = 1.0, apar_soilm = 0.0, bpar_soilm = 0.7330 )
plot(vec_soilm, vec_soilmstress)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-13"/></p>

<p>Similar to above, the soil moisture dependence of LUE (and hence GPP, and Vcmax) can be calculated directly using the function <code>soilmstress()</code> and affects several quantities returned by the <code>rpmodel()</code> call (GPP, LUE, Vcmax):</p>

<pre><code class="r">out_pmodel_soilmstress_OFF &lt;- rpmodel( 
  tc             = 20,           # temperature, deg C
  vpd            = 1000,         # Pa,
  co2            = 400,          # ppm,
  fapar          = 1,            # fraction  ,
  ppfd           = 30,           # mol/m2/d,
  elv            = 0,            # m.a.s.l.,
  do_ftemp_kphio = FALSE,
  do_soilmstress = FALSE
  )
out_pmodel_soilmstress_ON &lt;- rpmodel( 
  tc             = 20,           # temperature, deg C
  vpd            = 1000,         # Pa,
  co2            = 400,          # ppm,
  fapar          = 1,            # fraction  ,
  ppfd           = 30,           # mol/m2/d,
  elv            = 0,            # m.a.s.l.,
  do_ftemp_kphio = FALSE,
  do_soilmstress = TRUE,
  soilm          = 0.2,
  apar_soilm     = 0.1,
  bpar_soilm     = 0.7,
  meanalpha      = 0.2 
  )
print(paste(&quot;LUE soilmstress_ON /LUE soilmstress_OFF =&quot;, out_pmodel_soilmstress_ON$lue / out_pmodel_soilmstress_OFF$lue))
</code></pre>

<pre><code>## [1] &quot;LUE soilmstress_ON /LUE soilmstress_OFF = &quot;
</code></pre>

<pre><code class="r">print(paste(&quot;GPP soilmstress_ON /GPP soilmstress_OFF =&quot;, out_pmodel_soilmstress_ON$gpp / out_pmodel_soilmstress_OFF$gpp))
</code></pre>

<pre><code>## [1] &quot;GPP soilmstress_ON /GPP soilmstress_OFF = 0.662222222222222&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;Vcmax soilmstress_ON /Vcmax soilmstress_OFF =&quot;, out_pmodel_soilmstress_ON$vcmax / out_pmodel_soilmstress_OFF$vcmax))
</code></pre>

<pre><code>## [1] &quot;Vcmax soilmstress_ON /Vcmax soilmstress_OFF = 0.662222222222222&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;soilmstress(0.2, apar_soilm = 0.1, bpar_soilm = 0.7, meanalpha = 0.2) =&quot;, soilmstress(0.2, apar_soilm = 0.1, bpar_soilm = 0.7, meanalpha = 0.2)))
</code></pre>

<pre><code>## [1] &quot;soilmstress(0.2, apar_soilm = 0.1, bpar_soilm = 0.7, meanalpha = 0.2) = 0.662222222222222&quot;
</code></pre>

<p><code>ftemp_arrh()</code> Calculates the Arrhenius-type temperature response.</p>

<!-- ## Response to CO2 -->

<!-- ```{r} -->

<!-- library(ggplot) -->

<!-- df <- tibble( -->

<!--   tc             = rep(20, 100), -->

<!--   vpd            = rep(1000, 100), -->

<!--   co2            = seq(360, 1000, length.out = 100), -->

<!--   fapar          = rep(1, 100), -->

<!--   ppfd           = rep(100, 100) -->

<!--   ) %>% &ndash;>

<!--   dplyr::mutate( out_pmodel_simpl = purrr::pmap(., rpmodel, -->

<!--     elv            = 0, -->

<!--     kphio          = 0.05, -->

<!--     beta           = 146, -->

<!--     method_optci   = "prentice14", -->

<!--     method_jmaxlim = "none", -->

<!--     do_ftemp_kphio = FALSE -->

<!--     ) ) %>% &ndash;>

<!--   dplyr::mutate( out_pmodel_full = purrr::pmap(dplyr::select(., 1:5), rpmodel,  -->

<!--     elv            = 0,          -->

<!--     kphio          = 0.05,          -->

<!--     beta           = 146, -->

<!--     method_optci   = "prentice14", -->

<!--     method_jmaxlim = "wang17", -->

<!--     do_ftemp_kphio = FALSE -->

<!--     ) ) %>%  &ndash;>

<!--   dplyr::mutate( out_pmodel_simpl = purrr::map(out_pmodel_simpl, ~as_tibble(.))) %>% &ndash;>

<!--   dplyr::mutate( out_pmodel_full  = purrr::map(out_pmodel_full,  ~as_tibble(.))) -->

<!-- df %>%  &ndash;>

<!--   tidyr::unnest(out_pmodel_full) %>%  &ndash;>

<!--   dplyr::select(co2, out_pmodel_simpl, gpp_full = gpp) %>%  &ndash;>

<!--   tidyr::unnest(out_pmodel_simpl) %>%  &ndash;>

<!--   dplyr::select(co2, gpp_full, gpp_simpl = gpp) %>%  &ndash;>

<!--   tidyr::gather(method, gpp, c(gpp_full, gpp_simpl)) %>%  &ndash;>

<!--   ggplot(aes(x = co2, y = gpp, color = method)) + -->

<!--   geom_line() -->

<!-- ``` -->

<h2>References</h2>

<p>Stocker, B. D., Wang, H., Smith, N. G., Harrison, S. P., Keenan, T. F., Sandoval, D., Davis, T., and Prentice, I. C.: P-model v1.0: An optimality-based light use efficiency model for simulating ecosystem gross primary production, Geosci. Model Dev. Discuss., <a href="https://doi.org/10.5194/gmd-2019-200">https://doi.org/10.5194/gmd-2019-200</a>, in review, 2019.</p>

</body>

</html>
